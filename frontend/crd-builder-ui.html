<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KubeBuilder - Custom Resource Builder</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --k8s-blue: #326ce5;
        --k8s-blue-deep: #1f53c7;
        --k8s-blue-faint: #e9f0ff;
        --k8s-ink: #0f1b3d;
        --k8s-muted: #5b6787;
        --k8s-line: #d3deff;
        --k8s-surface: #ffffff;
        --k8s-bg: #f4f7ff;
        --k8s-slate: #1d2639;
        --k8s-success: #18794e;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        color: var(--k8s-ink);
        background:
          radial-gradient(circle at 20% -5%, #b8ccff 0%, rgba(184, 204, 255, 0) 38%),
          radial-gradient(circle at 85% -15%, #dce8ff 0%, rgba(220, 232, 255, 0) 34%),
          var(--k8s-bg);
      }

      .shell {
        max-width: 1240px;
        margin: 0 auto;
        padding: 32px 20px 40px;
      }

      .topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 26px;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .brand-mark {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        display: grid;
        place-items: center;
        font-weight: 700;
        color: #fff;
        background: linear-gradient(140deg, var(--k8s-blue), var(--k8s-blue-deep));
        box-shadow: 0 8px 20px rgba(50, 108, 229, 0.25);
      }

      .brand h1 {
        margin: 0;
        font-size: 1.1rem;
      }

      .badge {
        border: 1px solid var(--k8s-line);
        background: #fff;
        color: var(--k8s-muted);
        border-radius: 999px;
        padding: 7px 12px;
        font-size: 0.8rem;
      }

      .hero {
        border: 1px solid var(--k8s-line);
        border-radius: 24px;
        background:
          linear-gradient(130deg, #fff 20%, rgba(233, 240, 255, 0.7) 120%),
          #fff;
        box-shadow:
          0 24px 55px rgba(17, 45, 115, 0.09),
          inset 0 1px 0 rgba(255, 255, 255, 0.85);
        padding: 28px;
      }

      .hero-head {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 20px;
        margin-bottom: 22px;
      }

      .hero-head h2 {
        margin: 0 0 8px;
        font-size: clamp(1.4rem, 1.6vw + 1rem, 2rem);
      }

      .hero-head p {
        margin: 0;
        color: var(--k8s-muted);
        line-height: 1.5;
        max-width: 64ch;
      }

      .hero-pills {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .hero-pill {
        background: var(--k8s-blue-faint);
        color: var(--k8s-blue-deep);
        border: 1px solid #c8d9ff;
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 0.78rem;
        font-weight: 600;
      }

      .hero-grid {
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 20px;
      }

      .panel {
        background: var(--k8s-surface);
        border: 1px solid var(--k8s-line);
        border-radius: 18px;
        padding: 16px;
      }

      .panel-title {
        margin: 0 0 10px;
        font-size: 0.9rem;
        font-weight: 600;
      }

      .panel-subtitle {
        margin: 0 0 12px;
        color: var(--k8s-muted);
        font-size: 0.85rem;
      }

      textarea,
      input,
      select,
      button {
        font: inherit;
      }

      textarea,
      input {
        width: 100%;
        border: 1px solid var(--k8s-line);
        background: #fff;
        border-radius: 11px;
        color: var(--k8s-ink);
        padding: 11px 12px;
      }

      textarea {
        min-height: 158px;
        resize: vertical;
        line-height: 1.4;
      }

      textarea:focus,
      input:focus,
      select:focus {
        outline: 2px solid rgba(50, 108, 229, 0.22);
        border-color: var(--k8s-blue);
      }

      .button-row {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .button {
        border: 0;
        border-radius: 11px;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.12s ease, box-shadow 0.12s ease;
      }

      .button:active {
        transform: translateY(1px);
      }

      .button-primary {
        background: linear-gradient(130deg, var(--k8s-blue), var(--k8s-blue-deep));
        color: #fff;
        padding: 10px 15px;
        box-shadow: 0 8px 18px rgba(50, 108, 229, 0.25);
      }

      .button-secondary {
        border: 1px solid var(--k8s-line);
        background: #fff;
        color: var(--k8s-ink);
        padding: 10px 14px;
      }

      .file-picker {
        position: relative;
        overflow: hidden;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .file-picker input {
        position: absolute;
        inset: 0;
        opacity: 0;
        cursor: pointer;
      }

      .status {
        margin-top: 11px;
        min-height: 1.2rem;
        color: var(--k8s-muted);
        font-size: 0.84rem;
      }

      .status.ok {
        color: var(--k8s-success);
      }

      .template-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .template-chip {
        padding: 10px 13px;
        border-radius: 999px;
        border: 1px solid var(--k8s-line);
        background: #fff;
        color: var(--k8s-ink);
        cursor: pointer;
        font-weight: 500;
      }

      .template-chip.active {
        background: var(--k8s-blue);
        border-color: var(--k8s-blue);
        color: #fff;
      }

      .template-note {
        margin-top: 10px;
        color: var(--k8s-muted);
        font-size: 0.83rem;
      }

      .workspace {
        margin-top: 24px;
        display: grid;
        gap: 20px;
        grid-template-columns: minmax(340px, 1fr) minmax(380px, 1fr);
      }

      .workspace .panel {
        padding: 18px;
      }

      .panel-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        margin-bottom: 14px;
      }

      .panel-head h3 {
        margin: 0;
        font-size: 1.03rem;
      }

      .resource-tag {
        border-radius: 999px;
        border: 1px solid #bfd2ff;
        background: #edf3ff;
        color: var(--k8s-blue-deep);
        padding: 5px 10px;
        font-size: 0.74rem;
        font-weight: 600;
      }

      .field-list {
        display: grid;
        gap: 12px;
      }

      .field-card {
        border: 1px solid var(--k8s-line);
        border-radius: 12px;
        padding: 11px;
        background: #fff;
      }

      .field-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }

      .field-label {
        font-size: 0.87rem;
        font-weight: 600;
      }

      .desc-toggle {
        border: 1px solid #bfd2ff;
        color: var(--k8s-blue-deep);
        background: #edf3ff;
        width: 24px;
        height: 24px;
        border-radius: 999px;
        display: grid;
        place-items: center;
        font-size: 0.76rem;
        font-weight: 700;
      }

      .field-description {
        display: none;
        margin-top: 7px;
        font-size: 0.8rem;
        color: var(--k8s-muted);
        background: #f6f9ff;
        border: 1px solid #dce6ff;
        border-radius: 9px;
        padding: 8px 9px;
      }

      .field-description.open {
        display: block;
      }

      .add-field {
        margin-top: 14px;
        border: 1px dashed #b9cbfa;
        border-radius: 13px;
        padding: 12px;
        background: #fafcff;
      }

      .add-field h4 {
        margin: 0 0 8px;
        font-size: 0.88rem;
      }

      .add-field .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
      }

      .toolbar {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .toolbar button {
        border-radius: 9px;
        border: 1px solid var(--k8s-line);
        background: #fff;
        cursor: pointer;
        color: var(--k8s-ink);
        padding: 7px 10px;
      }

      .code {
        margin: 0;
        min-height: 540px;
        border-radius: 14px;
        border: 1px solid #c8d6fa;
        background: #0d1430;
        color: #cdd8ff;
        padding: 15px;
        font-size: 0.84rem;
        line-height: 1.5;
        overflow: auto;
        font-family: "IBM Plex Mono", "SFMono-Regular", Menlo, Consolas, monospace;
      }

      .token-key {
        color: #93d0ff;
      }

      .token-value {
        color: #b7f59d;
      }

      .token-number {
        color: #ffd27f;
      }

      .token-boolean {
        color: #fd9ad6;
      }

      .footer-note {
        margin-top: 14px;
        color: var(--k8s-muted);
        font-size: 0.8rem;
      }

      @media (max-width: 1040px) {
        .hero-grid,
        .workspace {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 640px) {
        .shell {
          padding: 16px 12px 24px;
        }

        .hero,
        .panel {
          border-radius: 16px;
        }

        .add-field .row {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <header class="topbar">
        <div class="brand">
          <div class="brand-mark">KB</div>
          <h1>KubeBuilder Studio</h1>
        </div>
        <span class="badge">CRD Assistant UX Concept</span>
      </header>

      <section class="hero">
        <div class="hero-head">
          <div>
            <h2>Build Kubernetes Custom Resources Faster</h2>
            <p>
              Paste a CRD or pick a built-in template. Get form-based guidance with
              field descriptions, autocomplete hints, and instant YAML output.
            </p>
          </div>
          <div class="hero-pills">
            <span class="hero-pill">Autocomplete</span>
            <span class="hero-pill">Schema Hints</span>
            <span class="hero-pill">Live YAML</span>
          </div>
        </div>

        <div class="hero-grid">
          <div class="panel">
            <h3 class="panel-title">1) Bring Your CRD</h3>
            <p class="panel-subtitle">Paste YAML/JSON, or upload a `.yaml` / `.txt` file.</p>
            <textarea
              id="crdInput"
              placeholder="apiVersion: apiextensions.k8s.io/v1&#10;kind: CustomResourceDefinition&#10;spec:&#10;  group: snapshots.storage.k8s.io&#10;  names:&#10;    kind: VolumeSnapshot&#10;..."
            ></textarea>
            <div class="button-row">
              <button id="parseCrd" class="button button-primary">Parse CRD</button>
              <label class="button button-secondary file-picker">
                Upload File
                <input id="crdFile" type="file" accept=".yaml,.yml,.txt,.json" />
              </label>
            </div>
            <div id="importStatus" class="status"></div>
          </div>

          <div class="panel">
            <h3 class="panel-title">2) Or Start From Templates</h3>
            <p class="panel-subtitle">Click any template and customize it in the builder.</p>
            <div id="templateGrid" class="template-grid"></div>
            <p id="templateNote" class="template-note"></p>
          </div>
        </div>
      </section>

      <section class="workspace">
        <article class="panel">
          <div class="panel-head">
            <h3>Custom Resource Form</h3>
            <span id="resourceTag" class="resource-tag"></span>
          </div>
          <div id="fieldList" class="field-list"></div>

          <div class="add-field">
            <h4>Add field with autocomplete</h4>
            <div class="row">
              <input
                id="newFieldInput"
                list="fieldSuggestions"
                placeholder="Try: spec.volumeSnapshotClassName"
              />
              <button id="addFieldBtn" class="button button-secondary">Add Field</button>
            </div>
            <datalist id="fieldSuggestions"></datalist>
          </div>
          <p class="footer-note">
            Click the <strong>i</strong> on any field to see CRD-style descriptions.
          </p>
        </article>

        <article class="panel">
          <div class="panel-head">
            <h3>Generated YAML</h3>
            <div class="toolbar">
              <button id="copyYaml">Copy</button>
              <button id="resetFields">Reset</button>
            </div>
          </div>
          <pre id="yamlPreview" class="code"></pre>
        </article>
      </section>
    </div>

    <script>
      const templates = {
        deployment: {
          title: "Deployment",
          apiVersion: "apps/v1",
          kind: "Deployment",
          note: "Good default for stateless app rollout.",
          defaultFields: [
            { path: "metadata.name", label: "metadata.name", value: "web-app", description: "Unique name for this deployment object." },
            { path: "metadata.namespace", label: "metadata.namespace", value: "default", description: "Namespace where the deployment will be created." },
            { path: "spec.replicas", label: "spec.replicas", value: "3", type: "number", description: "Desired number of pod replicas to keep running." },
            { path: "spec.selector.matchLabels.app", label: "spec.selector.matchLabels.app", value: "web-app", description: "Label selector used to match managed pods." },
            { path: "spec.template.spec.containers[0].name", label: "spec.template.spec.containers[0].name", value: "app", description: "Container name inside the pod template." },
            { path: "spec.template.spec.containers[0].image", label: "spec.template.spec.containers[0].image", value: "nginx:1.27", description: "Container image and tag to deploy." }
          ],
          optionalFields: [
            { path: "spec.template.spec.containers[0].ports[0].containerPort", description: "Exposes a container port." },
            { path: "spec.strategy.type", description: "Rollout strategy type (RollingUpdate or Recreate)." },
            { path: "spec.template.spec.imagePullSecrets[0].name", description: "Secret used for private registry pulls." }
          ]
        },
        statefulset: {
          title: "StatefulSet",
          apiVersion: "apps/v1",
          kind: "StatefulSet",
          note: "Stable identities and ordered scaling for stateful apps.",
          defaultFields: [
            { path: "metadata.name", label: "metadata.name", value: "db-set", description: "Name for the StatefulSet object." },
            { path: "metadata.namespace", label: "metadata.namespace", value: "default", description: "Namespace where this StatefulSet is created." },
            { path: "spec.serviceName", label: "spec.serviceName", value: "db-headless", description: "Headless service name backing the StatefulSet network IDs." },
            { path: "spec.replicas", label: "spec.replicas", value: "2", type: "number", description: "Number of StatefulSet pod replicas." },
            { path: "spec.template.spec.containers[0].name", label: "spec.template.spec.containers[0].name", value: "postgres", description: "Primary container name." },
            { path: "spec.template.spec.containers[0].image", label: "spec.template.spec.containers[0].image", value: "postgres:17", description: "Container image used for stateful workload." }
          ],
          optionalFields: [
            { path: "spec.volumeClaimTemplates[0].metadata.name", description: "PVC template name attached to each pod replica." },
            { path: "spec.volumeClaimTemplates[0].spec.resources.requests.storage", description: "Requested storage for each pod volume claim." },
            { path: "spec.persistentVolumeClaimRetentionPolicy.whenDeleted", description: "PVC retention behavior when StatefulSet is deleted." }
          ]
        },
        pvc: {
          title: "PersistentVolumeClaim",
          apiVersion: "v1",
          kind: "PersistentVolumeClaim",
          note: "Request persistent storage with class and capacity.",
          defaultFields: [
            { path: "metadata.name", label: "metadata.name", value: "app-data", description: "Name for the PVC resource." },
            { path: "metadata.namespace", label: "metadata.namespace", value: "default", description: "Namespace where the PVC is created." },
            { path: "spec.accessModes[0]", label: "spec.accessModes[0]", value: "ReadWriteOnce", description: "Access mode for mounting this volume." },
            { path: "spec.storageClassName", label: "spec.storageClassName", value: "standard", description: "StorageClass to satisfy this claim." },
            { path: "spec.resources.requests.storage", label: "spec.resources.requests.storage", value: "20Gi", description: "Requested storage size for this claim." }
          ],
          optionalFields: [
            { path: "spec.volumeMode", description: "Filesystem or Block volume mode." },
            { path: "spec.selector.matchLabels.tier", description: "Select backing PV by label." },
            { path: "spec.dataSource.name", description: "Clone from a snapshot or PVC data source." }
          ]
        },
        volumesnapshot: {
          title: "VolumeSnapshot",
          apiVersion: "snapshot.storage.k8s.io/v1",
          kind: "VolumeSnapshot",
          note: "Capture persistent volume state for backup or clone workflows.",
          defaultFields: [
            { path: "metadata.name", label: "metadata.name", value: "db-snapshot-001", description: "Name for this VolumeSnapshot object." },
            { path: "metadata.namespace", label: "metadata.namespace", value: "default", description: "Namespace where snapshot metadata is stored." },
            { path: "spec.volumeSnapshotClassName", label: "spec.volumeSnapshotClassName", value: "csi-hostpath-snapclass", description: "Snapshot class that controls snapshot behavior." },
            { path: "spec.source.persistentVolumeClaimName", label: "spec.source.persistentVolumeClaimName", value: "db-data", description: "PVC name used as source for this snapshot." }
          ],
          optionalFields: [
            { path: "metadata.labels.backup", description: "Attach labels for backup lifecycle automation." },
            { path: "metadata.annotations.purpose", description: "Add operator-readable snapshot purpose metadata." },
            { path: "spec.source.volumeSnapshotContentName", description: "Reference pre-provisioned VolumeSnapshotContent." }
          ]
        },
        cronjob: {
          title: "CronJob",
          apiVersion: "batch/v1",
          kind: "CronJob",
          note: "Run scheduled jobs with Kubernetes-native retry policy.",
          defaultFields: [
            { path: "metadata.name", label: "metadata.name", value: "nightly-report", description: "CronJob resource name." },
            { path: "metadata.namespace", label: "metadata.namespace", value: "default", description: "Namespace where this cron job runs." },
            { path: "spec.schedule", label: "spec.schedule", value: "0 1 * * *", description: "Cron expression controlling execution schedule." },
            { path: "spec.jobTemplate.spec.template.spec.containers[0].name", label: "spec.jobTemplate.spec.template.spec.containers[0].name", value: "runner", description: "Container name in the generated job." },
            { path: "spec.jobTemplate.spec.template.spec.containers[0].image", label: "spec.jobTemplate.spec.template.spec.containers[0].image", value: "alpine:3.21", description: "Image run on each schedule trigger." },
            { path: "spec.jobTemplate.spec.template.spec.restartPolicy", label: "spec.jobTemplate.spec.template.spec.restartPolicy", value: "OnFailure", description: "Pod restart policy for failed executions." }
          ],
          optionalFields: [
            { path: "spec.concurrencyPolicy", description: "Allow, Forbid, or Replace when previous job still runs." },
            { path: "spec.successfulJobsHistoryLimit", description: "How many successful jobs to keep." },
            { path: "spec.failedJobsHistoryLimit", description: "How many failed jobs to keep." }
          ]
        }
      };

      const templateGrid = document.getElementById("templateGrid");
      const templateNote = document.getElementById("templateNote");
      const fieldList = document.getElementById("fieldList");
      const fieldSuggestions = document.getElementById("fieldSuggestions");
      const resourceTag = document.getElementById("resourceTag");
      const yamlPreview = document.getElementById("yamlPreview");
      const importStatus = document.getElementById("importStatus");
      const crdInput = document.getElementById("crdInput");

      const parseCrdBtn = document.getElementById("parseCrd");
      const crdFileInput = document.getElementById("crdFile");
      const addFieldBtn = document.getElementById("addFieldBtn");
      const newFieldInput = document.getElementById("newFieldInput");
      const copyYamlBtn = document.getElementById("copyYaml");
      const resetBtn = document.getElementById("resetFields");

      let activeTemplate = "volumesnapshot";
      let fieldState = [];

      function cloneField(field) {
        return {
          path: field.path,
          label: field.label || field.path,
          value: field.value || "",
          description: field.description || "No description available.",
          type: field.type || "string"
        };
      }

      function initTemplateChips() {
        templateGrid.innerHTML = "";
        Object.keys(templates).forEach((key) => {
          const chip = document.createElement("button");
          chip.className = "template-chip";
          chip.textContent = templates[key].title;
          chip.dataset.template = key;
          chip.addEventListener("click", () => selectTemplate(key));
          templateGrid.appendChild(chip);
        });
        refreshChipState();
      }

      function refreshChipState() {
        Array.from(templateGrid.querySelectorAll(".template-chip")).forEach((chip) => {
          chip.classList.toggle("active", chip.dataset.template === activeTemplate);
        });
      }

      function selectTemplate(name) {
        activeTemplate = name;
        fieldState = templates[name].defaultFields.map(cloneField);
        templateNote.textContent = templates[name].note;
        resourceTag.textContent = templates[name].kind;
        importStatus.className = "status";
        importStatus.textContent = "";
        newFieldInput.value = "";
        refreshChipState();
        renderSuggestions();
        renderFields();
        renderYaml();
      }

      function renderSuggestions() {
        fieldSuggestions.innerHTML = "";
        const schema = templates[activeTemplate];
        const existingPaths = new Set(fieldState.map((field) => field.path));
        schema.optionalFields
          .filter((field) => !existingPaths.has(field.path))
          .forEach((field) => {
            const option = document.createElement("option");
            option.value = field.path;
            fieldSuggestions.appendChild(option);
          });
      }

      function renderFields() {
        fieldList.innerHTML = "";
        fieldState.forEach((field, index) => {
          const card = document.createElement("div");
          card.className = "field-card";

          const row = document.createElement("div");
          row.className = "field-row";

          const label = document.createElement("label");
          label.className = "field-label";
          label.setAttribute("for", `field-${index}`);
          label.textContent = field.label;

          const descButton = document.createElement("button");
          descButton.className = "desc-toggle";
          descButton.type = "button";
          descButton.textContent = "i";

          const input = document.createElement("input");
          input.id = `field-${index}`;
          input.value = field.value;
          input.placeholder = `Set ${field.label}`;
          input.addEventListener("input", (event) => {
            fieldState[index].value = event.target.value;
            renderYaml();
          });

          const description = document.createElement("div");
          description.className = "field-description";
          description.textContent = field.description;

          descButton.addEventListener("click", () => {
            description.classList.toggle("open");
          });

          row.append(label, descButton);
          card.append(row, input, description);
          fieldList.appendChild(card);
        });
      }

      function convertValue(field) {
        const raw = field.value.trim();
        if (raw === "") {
          return "";
        }
        if (field.type === "number" || /^-?\d+(\.\d+)?$/.test(raw)) {
          return Number(raw);
        }
        if (raw === "true") return true;
        if (raw === "false") return false;
        return raw;
      }

      function pathSegments(path) {
        const segments = [];
        path.split(".").forEach((part) => {
          const matches = [...part.matchAll(/^([^\[]+)|\[(\d+)\]/g)];
          matches.forEach((match) => {
            if (match[1]) {
              segments.push(match[1]);
            } else if (match[2]) {
              segments.push(Number(match[2]));
            }
          });
        });
        return segments;
      }

      function setDeepValue(target, path, value) {
        const segments = pathSegments(path);
        let current = target;
        for (let i = 0; i < segments.length; i += 1) {
          const key = segments[i];
          const nextKey = segments[i + 1];
          const isLast = i === segments.length - 1;

          if (isLast) {
            if (typeof key === "number") {
              if (!Array.isArray(current)) {
                return;
              }
              current[key] = value;
            } else {
              current[key] = value;
            }
            return;
          }

          if (typeof key === "number") {
            if (!Array.isArray(current)) {
              return;
            }
            if (current[key] === undefined) {
              current[key] = typeof nextKey === "number" ? [] : {};
            }
            current = current[key];
          } else {
            if (current[key] === undefined) {
              current[key] = typeof nextKey === "number" ? [] : {};
            }
            current = current[key];
          }
        }
      }

      function toYaml(value, level = 0) {
        const indent = "  ".repeat(level);
        if (Array.isArray(value)) {
          if (value.length === 0) return `${indent}[]`;
          return value
            .map((item) => {
              if (typeof item === "object" && item !== null) {
                const nested = toYaml(item, level + 1);
                return `${indent}-\n${nested}`;
              }
              return `${indent}- ${formatScalar(item)}`;
            })
            .join("\n");
        }
        if (typeof value === "object" && value !== null) {
          const entries = Object.entries(value);
          if (entries.length === 0) return `${indent}{}`;
          return entries
            .map(([key, nestedValue]) => {
              if (typeof nestedValue === "object" && nestedValue !== null) {
                return `${indent}${key}:\n${toYaml(nestedValue, level + 1)}`;
              }
              return `${indent}${key}: ${formatScalar(nestedValue)}`;
            })
            .join("\n");
        }
        return `${indent}${formatScalar(value)}`;
      }

      function formatScalar(value) {
        if (typeof value === "string") {
          if (value === "") return "\"\"";
          if (/^[a-zA-Z0-9_.-]+$/.test(value)) return value;
          return JSON.stringify(value);
        }
        if (typeof value === "number") return String(value);
        if (typeof value === "boolean") return value ? "true" : "false";
        return "null";
      }

      function highlightYaml(rawYaml) {
        return rawYaml
          .split("\n")
          .map((line) => {
            const escaped = line
              .replaceAll("&", "&amp;")
              .replaceAll("<", "&lt;")
              .replaceAll(">", "&gt;");
            const match = escaped.match(/^(\s*-?\s*)([A-Za-z0-9_.-]+):(.*)$/);
            if (!match) {
              return escaped;
            }
            const prefix = match[1];
            const key = match[2];
            const value = match[3];
            const trimmed = value.trim();
            if (trimmed === "") {
              return `${prefix}<span class="token-key">${key}</span>:`;
            }
            const displayValue = trimmed
              .replace(/^"([^"]*)"$/, "$1")
              .replace(/^'(.*)'$/, "$1");
            let tokenClass = "token-value";
            if (/^-?\d+(\.\d+)?$/.test(displayValue)) {
              tokenClass = "token-number";
            } else if (displayValue === "true" || displayValue === "false") {
              tokenClass = "token-boolean";
            }
            return `${prefix}<span class="token-key">${key}</span>: <span class="${tokenClass}">${trimmed}</span>`;
          })
          .join("\n");
      }

      function renderYaml() {
        const schema = templates[activeTemplate];
        const resource = {
          apiVersion: schema.apiVersion,
          kind: schema.kind
        };

        fieldState.forEach((field) => {
          setDeepValue(resource, field.path, convertValue(field));
        });

        const yaml = toYaml(resource);
        yamlPreview.dataset.raw = yaml;
        yamlPreview.innerHTML = highlightYaml(yaml);
      }

      function addFieldFromInput() {
        const input = newFieldInput.value.trim();
        if (!input) return;
        const schema = templates[activeTemplate];
        const optional = schema.optionalFields.find((field) => field.path === input);
        const exists = fieldState.some((field) => field.path === input);

        if (exists) {
          importStatus.className = "status";
          importStatus.textContent = "Field already exists in this resource form.";
          return;
        }

        if (optional) {
          fieldState.push(cloneField({ ...optional, value: "" }));
          renderSuggestions();
          renderFields();
          renderYaml();
          newFieldInput.value = "";
          importStatus.className = "status ok";
          importStatus.textContent = `Added field: ${optional.path}`;
          return;
        }

        fieldState.push(
          cloneField({
            path: input,
            label: input,
            value: "",
            description: "Custom field added manually. Consider validating against your CRD schema."
          })
        );
        renderFields();
        renderYaml();
        newFieldInput.value = "";
        importStatus.className = "status ok";
        importStatus.textContent = `Added custom field: ${input}`;
      }

      function parseCrdText(raw) {
        const text = raw || "";
        if (!text.trim()) {
          importStatus.className = "status";
          importStatus.textContent = "Paste or upload a CRD before parsing.";
          return;
        }

        const group = text.match(/^\s*group:\s*([A-Za-z0-9.-]+)/m)?.[1];
        const version =
          text.match(/^\s*-\s*name:\s*(v[0-9A-Za-z.-]+)/m)?.[1] ||
          text.match(/^\s*version:\s*(v[0-9A-Za-z.-]+)/m)?.[1];
        const kind =
          text.match(/names:\s*(?:\n[^\n]*){0,10}\n\s*kind:\s*([A-Za-z0-9]+)/m)?.[1] ||
          text.match(/^\s*kind:\s*([A-Za-z0-9]+)/m)?.[1] ||
          "CustomResource";

        const apiVersion = group && version ? `${group}/${version}` : "example.io/v1";

        const extracted = [];
        const propRegex = /^\s{8,}([A-Za-z][A-Za-z0-9_-]*):\s*$/gm;
        let match = propRegex.exec(text);
        while (match) {
          const field = match[1];
          if (
            !["type", "properties", "items", "description", "required", "metadata", "spec", "status"].includes(
              field
            ) &&
            !extracted.includes(field)
          ) {
            extracted.push(field);
          }
          match = propRegex.exec(text);
        }

        const inferredFields = extracted.slice(0, 7).map((field) => ({
          path: `spec.${field}`,
          label: `spec.${field}`,
          value: "",
          description: `Inferred from CRD schema property '${field}'.`
        }));

        const customTemplate = {
          title: `${kind} (Parsed)`,
          apiVersion,
          kind,
          note: "Template generated from pasted CRD schema. Review inferred fields before applying.",
          defaultFields: [
            { path: "metadata.name", label: "metadata.name", value: `${kind.toLowerCase()}-sample`, description: "Name for this custom resource." },
            { path: "metadata.namespace", label: "metadata.namespace", value: "default", description: "Namespace where this resource will be created." },
            ...inferredFields
          ],
          optionalFields: [
            { path: "metadata.labels.app", description: "Optional labels for grouping and selectors." },
            { path: "metadata.annotations.owner", description: "Optional annotations for operator metadata." }
          ]
        };

        templates.custom = customTemplate;
        if (!templateGrid.querySelector('[data-template="custom"]')) {
          const chip = document.createElement("button");
          chip.className = "template-chip";
          chip.dataset.template = "custom";
          chip.textContent = "Parsed CRD";
          chip.addEventListener("click", () => selectTemplate("custom"));
          templateGrid.appendChild(chip);
        }

        importStatus.className = "status ok";
        importStatus.textContent = `Parsed CRD -> ${kind} (${apiVersion}). Added a "Parsed CRD" template.`;
        selectTemplate("custom");
      }

      parseCrdBtn.addEventListener("click", () => parseCrdText(crdInput.value));
      crdFileInput.addEventListener("change", async (event) => {
        const [file] = event.target.files || [];
        if (!file) return;
        const text = await file.text();
        crdInput.value = text;
        parseCrdText(text);
      });

      addFieldBtn.addEventListener("click", addFieldFromInput);
      newFieldInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          addFieldFromInput();
        }
      });

      copyYamlBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(yamlPreview.dataset.raw || "");
          importStatus.className = "status ok";
          importStatus.textContent = "YAML copied to clipboard.";
        } catch (error) {
          importStatus.className = "status";
          importStatus.textContent = "Clipboard copy failed in this browser context.";
        }
      });

      resetBtn.addEventListener("click", () => {
        selectTemplate(activeTemplate);
        importStatus.className = "status ok";
        importStatus.textContent = "Fields reset to template defaults.";
      });

      initTemplateChips();
      selectTemplate(activeTemplate);
    </script>
  </body>
</html>
